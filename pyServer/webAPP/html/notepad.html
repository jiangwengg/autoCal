<html>
<head>
	<meta charset="utf-8">
	<title>自动标定系统</title>
	<decription>编程的一大痛苦是，你只能在你擅长的领域进行选择</decription>
	<link rel="stylesheet" href="../layui/css/layui.css">
	<script src="../js/jquery-1.8.2.min.js"></script>
	<script src="../layui/layui.js"></script>
	<script src="../js/app.js"></script>
</head>
	<body>
		变量定义设计思路: 页面与后台接口联动，提供对变量表的增删改查功能。
		输入参数和输出参数还是要在数据库区分开来，到时候可以定义子类，提供不同的方法做钩子。
		所以数据库要增加is_input字段。
		所以在内存中需要保存两个字典存储变量，一个定义输入一个定义输出。

		页面详细设计
		首先有一个列表，显示用户已经定义的所有变量(就懒得给他做分页了)
		然后已经定义的变量可以被修改，删除
		然后可以新增变量定义
		变量的参数包括c_name, e_name, code, is_input
		好了开工

		2018/8/20
		好了，变量，工况，运行这三大问题基本上算是解决了
		下面要面对的是这些问题。
		1. 数据库重置脚本，编写好然后测试一下
		2. 运行历史记录，这个要想办法找个数据结构，将运行状态序列化写入。最好能做图表化输出
		3. 全局工况，这个只能看客户那边想怎么做了，等问清楚

		全局工况是这么回事
		设定一个全局参数，保存全局工况的刷新频率
		所有全局工况的刷新频率都是全局刷新频率的整数倍

		2018/8/21
		输出变量增加阈值功能，在每次setValue时先进行阈值判断，不可以超过阈值范围。
		我懒惰，又不想分表，那就只能输入变量也加咯？
		不管分不分表，前台页面是需要分的，这个没办法
		那么首先就是改变表，然后进行表和前台页面的设置吧。
		阈值数据类型用double

		数据库增加max_value min_value, 都是double类型
		模型层面修改，输出变量新增这两个field
		页面和相应方法都做了修改，现在有一个问题是这样的
		最大值最小值需要自定义输入规则(先不做了)
		变量删除前需要进行校验，该变量是否被使用

		赋值和计算功能不明确，现在要重新做一下
		赋值
		=100
		=-100
		计算
		+100
		-100
		要改正则表达式和后台识别，数据库存储varchar ,后台转换float 注意异常处理和报错

		这一块现在工况能跑起来了，赋值和计算也区分清楚了，输出变量的阈值设定也OK了

		那么本周剩下的工作内容就是全局工况这么个东西了，今天先滚去写文档了
		对了工况运行的历史记录也要做

		文档写完了，滚回来了
		
		今天先做一下全局工况的设计好了
		全局工况，其实就是在全局运行的，有interval的，有条件判断，可以改变输出变量的条目
		我可以给全局工况做一个开关来着，
		全局工况，进行条件判断的必然是输入变量，被改变的必然是输出变量
		这样就简单咯~

		if (exec(input_var + code)):
			output_code
		类似这样就好

		关于定时刷新的事情，可以考虑这样做

		x = 1

		setInterval(function({
			if (x / 倍数 == 0) {
				xxx
			}
			if (x / 倍数 == 0) {
				xxx
			}
			x++
		}), interval_value)

		新问题，倍数是有限多个还是无限多个？

		如果是无限多个，在最简单的代码模式下，我需要启动和全局变量设定数量相同的条件判断
		如果是有限多个，我只需要设置和这些次数一样多的条件判断
		这里我需要想一下，如果倍数是无限多个，我可以动态生成有限多个判断吗？

		从数据库加载变量时，即可按照倍数排序，从低到高排序，然后加载进内存？

		然后用如下数据结构保存？

		一个字典结构，key是倍数，value是全局工况对象列表
		如下
		{
			1 : [{},{},{}],
			2 : [{},{},{}]
		}
		执行时，遍历key，执行if (x / key == 0) 这样的语句，判断成功则依次执行列表内的代码

		ok，还有一个小tips，就是被禁用的全局变量不加载到内存，减少内存消耗。
		恩啦，设计如上，明天开工

		2018/8/22
		全局工况的增删改查应该是施工完毕了
		帮助文档还需要写一下子
		明天写一下帮助文档，然后写全局工况的加载运行

		2018/8/23
		运行ok，写一个测试，定义一个全局工况脚本，让某个输入变量每秒加一
		当输入变量超过全局工况的阈值后，全局工况将使某个输出变量也开始每秒加一
		两个全局工况同时运行，观看变量运行规律
		全局工况的增删改查，运行功能已经完工了

		现在是执行记录的保存，执行记录的载入问题。
		执行记录载入，一定要约定好数据结构，文件内需要保存的内容分为两部分。
		第一，变量的名称和id的关系，可以采用JSON格式
		第二，在不同的时间节点，变量的id和值的关系。
		设计如下，运行时可以选择直接运行工况，或运行并保存记录。直接运行和现在的模式相同
		如果选择运行并保存记录，则按照当前时间戳生成两个文件，在运行前，直接写好一个文件，其中是json格式的id和值的关系。结构如下
		{
			var_names : {id : name, id : name, id: name},
			interval : 1
		}
		在运行中，启动一个线程写入另一个文件，按照给定的时间频率对文件进行写入。写入的是所有变量在时间节点的值。时间节点采用绝对时间记录。数据结构如下
		[
			0 : {time : xxxx, input_vars : [0 : {id: value}, 1: {id, value}], output_vars : [0 : {id: value}, 1: {id, value}]}
			1 : {time : xxxx, input_vars : [0 : {id: value}, 1: {id, value}], output_vars : [0 : {id: value}, 1: {id, value}]}
		]
		如此便可以通过两个文件记录一次工况运行的完整信息(如果以后需要工况执行节点信息，可以通过第三个文件实现)
		文件命名可以按照如此规则: record/timestamp/baseInfo record/timestamp/data 这样的两个文件名即可
		需要解决的功能点，py对象转JSON对象序列化
		文件写入有几种方案可以选择，后台保存一次性写入，逐行写入，缓存写入。
		既然前台无法读取本地文件，意味着数据只能通过后台转换为JSON对象发给前台。那么必然存在着内存中加载全量数据的情况。决定采用后台保存一次性写入的方式进行文件操作。

		2018/8/24
		可以保存和读取历史文件了，现在要用Echarts做个数据可视化。然后完事

		本周以完成:
		数据库重置脚本和功能
		输出变量边界
		条目脚本格式优化
		全局工况配置与运行
		运行历史与读取


		2018/9/17
		暂停和停止功能实现
		首先，现在的工况运行要更改为新线程运行，不能使用主线程跑工况
		然后所谓的暂停，停止，其实就是把新开的线程暂停掉，或者停止掉就好了

		线程已经有了相关Demo，需要设计线程停止功能等
		
	</body>
</html>